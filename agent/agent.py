import asyncio
import os
from dataclasses import dataclass
from datetime import datetime
from typing import List, TextIO

from openai import OpenAI
from pyppeteer import launch

from dotenv import load_dotenv

try:
    from cli import parse_args
except ModuleNotFoundError:  # Running as package
    from agent.cli import parse_args  # type: ignore

load_dotenv()


@dataclass
class Task:
    """A high-level description of an action to complete."""

    description: str


class WebAgent:
    """Goal-oriented web assistant using Pyppeteer and OpenAI."""

    def __init__(
        self,
        api_key: str,
        endpoint: str,
        headless: bool = False,
        *,
        verbose: bool = False,
        log_path: str | None = None,
    ) -> None:
        self.api_key = api_key
        self.endpoint = f"{endpoint}"
        self.client = OpenAI(
            base_url=endpoint,
            api_key=api_key
        )
        self.headless = headless
        self.browser = None
        self.page = None
        self.tasks: List[Task] = []
        self.goal: str | None = None
        self.verbose = verbose
        self.log_path = log_path or "web_agent.log"
        self.log_file: TextIO | None = None

        if self.verbose:
            resolved_path = os.path.abspath(self.log_path)
            directory = os.path.dirname(resolved_path)
            if directory and not os.path.exists(directory):
                os.makedirs(directory, exist_ok=True)
            self.log_file = open(resolved_path, "w", encoding="utf-8")
            self.log(f"Verbose logging enabled. Writing to {resolved_path}")

    def log(self, message: str) -> None:
        """Log a message to stdout and the configured log file when verbose is enabled."""
        if not self.verbose:
            return
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        formatted = f"[{timestamp}] {message}"
        print(formatted)
        if self.log_file:
            self.log_file.write(formatted + "\n")
            self.log_file.flush()

    async def start_browser(self) -> None:
        """Launch a new browser session."""
        self.log("Launching browser session.")
        CHROME_PATH = r"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"  # or Edge path
        self.browser = await launch(
            headless=self.headless,
            executablePath=CHROME_PATH,
            args=[
                "--no-sandbox",
                "--disable-setuid-sandbox",
                "--disable-dev-shm-usage",
            ],
        )
        self.page = await self.browser.newPage()
        self.log("Browser session started.")

    async def close_browser(self) -> None:
        """Close the browser session."""
        if self.browser:
            await self.browser.close()
            self.log("Browser session closed.")
            self.browser = None
            self.page = None

    def plan_tasks(self, goal: str) -> None:
        """Break a goal into an initial list of tasks."""
        self.log(f"Planning tasks for goal: {goal}")
        self.goal = goal
        self.tasks.clear()
        response = self.client.chat.completions.create(
            model="gpt-5-mini",
            messages=[
                {
                    "role": "system",
                    "content": "Break the user's goal into an ordered list of web tasks.",
                },
                {"role": "user", "content": goal},
            ],
        )
        lines = [
            line.strip("- ")
            for line in response.choices[0].message.content.splitlines()
            if line.strip()
        ]
        for line in lines:
            task = Task(line)
            self.tasks.append(task)
            self.log(f"Task created: {task.description}")

        if not self.tasks:
            self.log("No tasks were generated by the planner.")

    async def execute_task(self, task: Task) -> None:
        """Ask the model how to satisfy a task and perform the action."""
        self.log(f"Executing task: {task.description}")
        html = await self.page.content()
        prompt = (
            "You control a browser. Given the HTML and a task, "
            "respond with an action in one of these forms:\n"
            "NAVIGATE <url>\nCLICK <css selector>\nTYPE <css selector> <text>\nDONE\n"
            f"HTML:\n{html[:2000]}\nTask: {task.description}"
        )
        response = self.client.chat.completions.create(
            model="gpt-5-mini",
            messages=[{"role": "user", "content": prompt}],
        )
        command = response.choices[0].message.content.strip()
        self.log(f"Model command: {command}")

        if command.upper().startswith("NAVIGATE"):
            url = command.split(maxsplit=1)[1]
            self.log(f"Navigating to {url}")
            await self.page.goto(url)
        elif command.upper().startswith("CLICK"):
            selector = command.split(maxsplit=1)[1]
            self.log(f"Clicking element: {selector}")
            await self.page.click(selector)
        elif command.upper().startswith("TYPE"):
            _, selector, text = command.split(" ", 2)
            self.log(f"Typing into {selector}: {text}")
            await self.page.type(selector, text)
        elif command.upper().startswith("DONE"):
            self.log("Task marked as DONE by model.")
            return
        else:
            self.log(f"Unknown command received: {command}")
            raise ValueError(f"Unknown command: {command}")

        html = await self.page.content()
        followup = (
            f"Goal: {self.goal}\nHTML:\n{html[:2000]}\n"
            "What is the next task? Reply DONE if the goal is complete."
        )
        next_step = self.client.chat.completions.create(
            model="gpt-5-mini",
            messages=[{"role": "user", "content": followup}],
        ).choices[0].message.content.strip()
        if next_step.upper() != "DONE":
            new_task = Task(next_step)
            self.tasks.append(new_task)
            self.log(f"Follow-up task created: {new_task.description}")
        else:
            self.log("Received DONE after follow-up; goal considered complete.")

    async def run(self, goal: str) -> None:
        """Start the agent with a goal and execute tasks sequentially."""
        self.log(f"Starting run with goal: {goal}")
        await self.start_browser()
        try:
            self.plan_tasks(goal)
            while self.tasks:
                task = self.tasks.pop(0)
                self.log(f"Dequeued task: {task.description}")
                await self.execute_task(task)
            self.log("All tasks completed.")
        finally:
            await self.close_browser()
            self.close_log()

    def close_log(self) -> None:
        """Close the verbose log file if it was opened."""
        if self.log_file:
            self.log("Closing verbose log.")
            self.log_file.close()
            self.log_file = None


async def main() -> None:
    args = parse_args()
    goal = args.goal
    api_key = os.getenv("OPENAI_API_KEY")
    endpoint = os.getenv("ENDPOINT")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY environment variable not set")
    verbose_env = os.getenv("AGENT_VERBOSE", "")
    verbose = args.verbose or verbose_env.lower() in {"1", "true", "yes", "on"}
    log_path = args.log_file or os.getenv("AGENT_LOG_PATH")
    agent = WebAgent(api_key, endpoint, verbose=verbose, log_path=log_path)
    await agent.run(goal)


if __name__ == "__main__":
    asyncio.run(main())
